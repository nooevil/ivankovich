import fs from 'fs';
import path from 'path';
import postcss from 'postcss';
import stylelint from 'stylelint';
import valueParser from 'postcss-values-parser';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

// return custom selectors from the css root, conditionally removing them
var getCustomPropertiesFromRoot = (root => {
  // initialize custom selectors
  const customProperties = {}; // for each custom property declaration

  root.walkDecls(customPropertyRegExp, decl => {
    const prop = decl.prop; // write the parsed value to the custom property

    customProperties[prop] = decl.value;
  }); // return all custom properties, preferring :root properties over html properties

  return customProperties;
}); // match custom properties

const customPropertyRegExp = /^--[A-z][\w-]*$/;

/* Get Custom Properties from CSS File
/* ========================================================================== */

function getCustomPropertiesFromCSSFile(_x) {
  return _getCustomPropertiesFromCSSFile.apply(this, arguments);
}
/* Get Custom Properties from Object
/* ========================================================================== */


function _getCustomPropertiesFromCSSFile() {
  _getCustomPropertiesFromCSSFile = _asyncToGenerator(function* (from) {
    const css = yield readFile(from);
    const root = postcss.parse(css, {
      from
    });
    return getCustomPropertiesFromRoot(root);
  });
  return _getCustomPropertiesFromCSSFile.apply(this, arguments);
}

function getCustomPropertiesFromObject(object) {
  const customProperties = Object.assign({}, Object(object).customProperties, Object(object)['custom-properties']);
  return customProperties;
}
/* Get Custom Properties from JSON file
/* ========================================================================== */


function getCustomPropertiesFromJSONFile(_x2) {
  return _getCustomPropertiesFromJSONFile.apply(this, arguments);
}
/* Get Custom Properties from JS file
/* ========================================================================== */


function _getCustomPropertiesFromJSONFile() {
  _getCustomPropertiesFromJSONFile = _asyncToGenerator(function* (from) {
    const object = yield readJSON(from);
    return getCustomPropertiesFromObject(object);
  });
  return _getCustomPropertiesFromJSONFile.apply(this, arguments);
}

function getCustomPropertiesFromJSFile(_x3) {
  return _getCustomPropertiesFromJSFile.apply(this, arguments);
}
/* Get Custom Properties from Sources
/* ========================================================================== */


function _getCustomPropertiesFromJSFile() {
  _getCustomPropertiesFromJSFile = _asyncToGenerator(function* (from) {
    const object = yield import(from);
    return getCustomPropertiesFromObject(object);
  });
  return _getCustomPropertiesFromJSFile.apply(this, arguments);
}

function getCustomPropertiesFromSources(sources) {
  return sources.map(source => {
    if (source instanceof Promise) {
      return source;
    } else if (source instanceof Function) {
      return source();
    } // read the source as an object


    const opts = source === Object(source) ? source : {
      from: String(source)
    }; // skip objects with Custom Properties

    if (opts.customProperties || opts['custom-properties']) {
      return opts;
    } // source pathname


    const from = path.resolve(String(opts.from || '')); // type of file being read from

    const type = (opts.type || path.extname(from).slice(1)).toLowerCase();
    return {
      type,
      from
    };
  }).reduce(
  /*#__PURE__*/
  function () {
    var _ref = _asyncToGenerator(function* (customProperties, source) {
      const _ref2 = yield source,
            type = _ref2.type,
            from = _ref2.from;

      if (type === 'css') {
        return Object.assign((yield customProperties), (yield getCustomPropertiesFromCSSFile(from)));
      }

      if (type === 'js') {
        return Object.assign((yield customProperties), (yield getCustomPropertiesFromJSFile(from)));
      }

      if (type === 'json') {
        return Object.assign((yield customProperties), (yield getCustomPropertiesFromJSONFile(from)));
      }

      return Object.assign((yield customProperties), (yield getCustomPropertiesFromObject((yield source))));
    });

    return function (_x4, _x5) {
      return _ref.apply(this, arguments);
    };
  }(), {});
}
/* Promise-ified utilities
/* ========================================================================== */

const readFile = from => new Promise((resolve, reject) => {
  fs.readFile(from, 'utf8', (error, result) => {
    if (error) {
      reject(error);
    } else {
      resolve(result);
    }
  });
});

const readJSON =
/*#__PURE__*/
function () {
  var _ref3 = _asyncToGenerator(function* (from) {
    return JSON.parse((yield readFile(from)));
  });

  return function readJSON(_x6) {
    return _ref3.apply(this, arguments);
  };
}();

var ruleName = 'csstools/value-no-unknown-custom-properties';

var messages = stylelint.utils.ruleMessages(ruleName, {
  unexpected: (name, prop) => `Unexpected custom property "${name}" inside declaration "${prop}".`
});

var validateDecl = ((decl, {
  result,
  customProperties
}) => {
  const valueAST = valueParser(decl.value).parse();
  validateValueAST(valueAST, {
    result,
    customProperties,
    decl
  });
}); // validate a value ast

const validateValueAST = (ast, {
  result,
  customProperties,
  decl
}) => {
  if (Object(ast.nodes).length) {
    ast.nodes.forEach(node => {
      if (isVarFunction(node)) {
        const _node$nodes$slice = node.nodes.slice(1, -1),
              _node$nodes$slice2 = _toArray(_node$nodes$slice),
              propertyNode = _node$nodes$slice2[0],
              comma = _node$nodes$slice2[1],
              fallbacks = _node$nodes$slice2.slice(2); // eslint-disable-line no-unused-vars


        const propertyName = String(propertyNode);

        if (propertyName in customProperties) {
          return;
        } // conditionally test fallbacks


        if (fallbacks.length) {
          validateValueAST({
            nodes: fallbacks.filter(isVarFunction)
          }, {
            result,
            customProperties,
            decl
          });
          return;
        } // report unknown custom properties


        stylelint.utils.report({
          message: messages.unexpected(propertyName, decl.prop),
          node: decl,
          result,
          ruleName,
          word: String(propertyNode)
        });
      } else {
        validateValueAST(node, {
          result,
          customProperties,
          decl
        });
      }
    });
  }
}; // match var() functions


const varRegExp = /^var$/i; // whether the node is a var() function

const isVarFunction = node => node.type === 'func' && varRegExp.test(node.value) && Object(node.nodes).length > 0;

var validateResult = ((result, customProperties) => {
  // validate each declaration
  result.root.walkDecls(decl => {
    if (hasCustomPropertyReference(decl)) {
      validateDecl(decl, {
        result,
        customProperties
      });
    }
  });
}); // match custom property inclusions

const customPropertyReferenceRegExp = /(^|[^\w-])var\([\W\w]+\)/; // whether a declaration references a custom property

const hasCustomPropertyReference = decl => customPropertyReferenceRegExp.test(decl.value);

var index = stylelint.createPlugin(ruleName, (method, opts) => {
  // sources to import custom selectors from
  const importFrom = [].concat(Object(opts).importFrom || []); // promise any custom selectors are imported

  const customPropertiesPromise = isMethodEnabled(method) ? getCustomPropertiesFromSources(importFrom) : {};
  return (
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(function* (root, result) {
        // validate the method
        const isMethodValid = stylelint.utils.validateOptions(result, ruleName, {
          actual: method,

          possible() {
            return isMethodEnabled(method) || isMethodDisabled(method);
          }

        });

        if (isMethodValid && isMethodEnabled(method)) {
          // all custom properties from the file and imports
          const customProperties = Object.assign((yield customPropertiesPromise), getCustomPropertiesFromRoot(root)); // validate the css root

          validateResult(result, customProperties);
        }
      });

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }()
  );
});

const isMethodEnabled = method => method === true;

const isMethodDisabled = method => method === null || method === false;

export default index;
export { ruleName };
//# sourceMappingURL=index.es.mjs.map
